//groovy
// Copyright (c) 2024 Advanced Micro Devices, Inc. All rights reserved.
// jenkinsfile: builds and archives all the FLM artifacts.

// Options set by the job configuration parameters or by environment variables.
// If using parameters, manual invocation requires two clicks (build with parameters, verify parameters and build)

import static groovy.io.FileType.*
import static groovy.io.FileVisitResult.*

// Set some constants and other variables
kMaxBuilds = 60
kMaxDays = 30
removeRepoWorkspace = false  // set to true if PR- or dev- branch and the build succeeds.

// Define the repo and project (not necessarily the same all the time)
repoName = "frame_latency_meter"
projName = "FLM"

versionMajor = 1
versionMinor = 0
versionStringFull = "$versionMajor $versionMinor $BUILD_NUMBER"

// The default repoBranch. This is actually not used, and the branch cannot be changed by the script,
// with enterprise github based jobs.
repoBranch = "amd-main"

// Define the test job to run. This can be changed in the environment. This can also be called
// on any other branch for now.
repoTestJob = ""

// And the packaging job, if it exists.
PackagingJob = ""

kServer = Artifactory.server ('DevToolsBDC')
kArtifactoryPath = "https://bdcartifactory.amd.com/artifactory/DevToolsBDC/Builds"

// Can be changed with an env var, if testing a modification to the JenkinsToolsLib.gvy script.
// Set the defaults for the scripts repo.
commonScriptsBranch = "amd-main"
commonScriptsUrl = "git@github.amd.com:Developer-Solutions/scripts"

jTools = null

winBuildLabel = 'BLD-WIN10'

// Use a VM for doing the prep work - reading in the JenkinsToolsLib file, setting up all the defaults.
workNodeLabel = 'BLD-LINUX-VM'

internalOption = ""
releaseDir = "Release"
debugDir = "Debug"

winSucceeded = null

// Downstream jobs to call, if any.
packagingJob = null

// test job
testJob = null

emailRecipFail = ""
emailRecipSuccess = ""

// The stashes, to use when uploading to artifactory when finished
stashNameWin = "winFLMpkg${BRANCH_NAME}.${BUILD_NUMBER}"

// Set these as a global, so that they can be used for describing the artifacts (build machines used)
winAgentName = ""

// Set up the commands and the branches to be used, depending upon how the job is invoked
// if the parent job is associated with a particular branch, or if it's triggered, then process
// this information here.
def setupJobVars() {
    // Defaults for FLM build
    internalOption = ""
    // toggle the booleans to true for individual builds with these variables in the env. settings in jenkins
    // 1 == true, 0 == false (use 1 or 0, not true/false)

    // Configure the downstream RDTS packaging job. Not sure if this is needed for FLM
    if (env.PACKAGINGJOB) {
        packagingJob = PACKAGINGJOB
    } else {
        // Build the amd-master branch package.
        packagingJob = ""
    }

    // If this is set, skip the packaging.
    if (env.SKIPPACKAGE) {
        skipPackage = true
    }
    // if there's an environment setting in the job for repoBranch and email recipients, not the default setting
    if (env.BRANCH_NAME) {
        repoBranch = BRANCH_NAME
    }
    // Set the retention values for PR- builds to be lower than for branch builds
    if (repoBranch.startsWith("PR-")) {
        kMaxBuilds = 5
        kMaxDays = 5
        skipRdtsPackage = true
        skipTests = true
        // This will happen only if currentBuild.Result == SUCCESS, though. If so, cleanWs() will be
        // called. Jenkins won't remove the top level WS name but will delete the contents.
        removeRepoWorkspace = true
    }
    // Similarly, for dev- branches (presumably created for development branches)
    def devMatchPattern = /[Dd][Ee][Vv][_-]/
    if (repoBranch.startsWith(devMatchPattern)) {
        kMaxBuilds = 5
        kMaxDays = 5
        skipRdtsPackage = true
        skipTests = true
        // This will happen only if currentBuild.Result == SUCCESS, though. If so, cleanWs() will be
        // called. Jenkins won't remove the top level WS name but will delete the contents.
        removeRepoWorkspace = true
    }
    // Set the retention values for amd-main to be 90 days, 150 builds.
    if (repoBranch == "amd-main") {
        kMaxBuilds = 150
        kMaxDays = 90
    }

    // Set up the test kit job to be invoked.
    if (env.TESTJOB) {
        // None at the moment
        testJob = TESTJOB
    }

    if (testJob == null) {
        testJob = repoTestJob
    }

    // Configure e-mail notifications.
    if (env.NOTIFY_FAIL) {
        emailRecipFail = NOTIFY_FAIL
    }

    if (env.NOTIFY_SUCCESS) {
        emailRecipSuccess = NOTIFY_SUCCESS
    }

    // toggle to false to force skipping the test job runs.
    if (env.SKIPTESTS) {
        skipTests = env.SKIPTESTS
    }

    // If needing to test a change to JenkinsToolsLib.gvy, on a branch
    if (env.COMMONSCRIPTSBRANCH) {
        commonScriptsBranch = COMMONSCRIPTSBRANCH
    }
}

def setupTools() {
    def jenkinsToolsLinux = "Scripts/lab_tools/Jenkins/Generic/JenkinsToolsLib.gvy"
    def jenkinsToolsWindows = "Scripts\\lab_tools\\Jenkins\\Generic\\JenkinsToolsLib.gvy"

    def loadedTools
    if (isUnix()) {
        jenkinsTools = jenkinsToolsLinux
    } else {
        jenkinsTools = jenkinsToolsWindows
    }
    catchError(stageResult: 'FAILURE', buildResult: 'FAILURE', message: 'There was a problem cloning the scripts repo.') {
            dir('Scripts') {
                git branch: "${commonScriptsBranch}", url: "${commonScriptsUrl}"
            }
        }
    if (currentBuild.result != 'FAILURE') {
        // Load the script.
        try {
            loadedTools = load(jenkinsTools)
        } catch (Exception err) {
            echo "Could not load "+ jenkinsTools + " " + err
            throw err
        }
    }
    echo "jenkinsTools loaded"
    return loadedTools
}

def cloneRepos() {
    dir (repoName) {
        try {
            checkout scm
        } catch (Exception err) {
            echo "Unable to clone the FLM AMD github repo"
            throw err
        }
    }
}


// Define the steps to be run on  each of the Windows machines.
def buildWindows(winNodeName) {
    node (winNodeName) {
        // set up the upload spec for this job
        winAgentName = "${env.NODE_NAME}"
        echo "Building on ${winAgentName}"
        osType = jTools.getOsType()
        currentBuild.result = 'SUCCESS'
        stage("Delete the ${repoName} directory") {
            jTools.cleanAll()
        }
        stage('Clone the repos') {
            // Define the cloning to be done.
            try {
                cloneRepos()
            } catch (Exception e) {
                echo "Unable to clone the repo on $winAgentName"
                throw e
            }
        }

        // Run the build
        stage('Run the jenkins build script') {
            catchError(stageResult: 'FAILURE', buildResult: 'FAILURE', message: "There was a problem building for Windows") {
                timeout(time: 180, unit: 'MINUTES') {
                    echo "Building the apps..."
                    dir ("$WORKSPACE\\${repoName}") {
                        withEnv(["_MSPDBSRV_ENDPOINT_=${BUILD_TAG}"]) {
                            bat """
                                @echo on
                                set MSBUILDDEBUGPATH=%WORKSPACE%
                                call build\\windows_build_apps.bat %WORKSPACE% 2>&1> %WORKSPACE%\\windows_build_apps.log
                                if %ERRORLEVEL% NEQ 0 exit /b 1
                                cd "${WORKSPACE}"
                                """
                        }
                    }
                }
            }
        }
        
        stage('Create Frame Latency Meter ZIP package for Windows') {
            try {
                dir ("$WORKSPACE\\${repoName}\\") {
                    withEnv(["_MSPDBSRV_ENDPOINT_=${BUILD_TAG}"]) {
                        bat """
                            @echo on
                            cd build\\win\\bin\\release
                            powershell compress-archive -Path flm.* -DestinationPath %WORKSPACE%\\${repoName}\\flm_${versionMajor}_${versionMinor}.zip
                            if %ERRORLEVEL% NEQ 0 exit /b 1
                            cd "${WORKSPACE}"
                            """
                    }
                }
            } catch (Exception err) {
                echo "There was a problem creating the Windows zip package " + err
                currentBuild.result = 'FAILURE'
            }
        }

        stage('Stash the results for the next steps') {
            try {
                stash includes: "*.log, ${repoName}\\*.zip", //${repoName}\\installer\\*\\*.exe, 
                         name: stashNameWin
            } catch (Exception err) {
                echo "There was a problem stashing the windows artifact files" + err
                currentBuild.result = 'FAILURE'
            }
        }
        stage("Set the status for the build") {
            echo "currentBuild.result = " + currentBuild.result
            if (currentBuild.result != 'SUCCESS') {
                winSucceeded = false
            } else {
                winSucceeded = true
                if (removeRepoWorkspace) {
                    cleanWs()
                }
            }
        }
    }
}

// Take all the stashed build results, and save them to one place under their own subdirectories.
def unstashAll() {
    // First, make sure that the directory is empty in all stash folders. This will assure that any artifacts from
    // old runs where OS builds were done aren't included in the artifacts for a run where an OS was skipped.
    dir ("Windows") {
        deleteDir()
    }
    try {
        echo "Unstashing the full package for windows."
        dir("Windows") {
            unstash stashNameWin
        }
    } catch (Exception eStash) {
        echo "windows stash was not found."
        throw eStash
    }
}

// After unstashing the build results, save them to artifactory.
def archivePackages() {
    // Unstash the various bits.
    unstashAll()
    // Set up the artifactory upload definitions.
    def buildInfo = Artifactory.newBuildInfo()
    buildInfo.env.capture = true
    buildInfo.number = "${env.BUILD_NUMBER}"
    buildInfo.retention maxBuilds: kMaxBuilds, maxDays: kMaxDays, deleteBuildArtifacts: true

    def uploadSpec = """ {
          "files": [
           {
              "pattern": "Windows/**",
              "target": "DevToolsBDC/Builds/${projName}/${env.JOB_NAME}/${BUILD_NUMBER}/Windows/"
           }
          ]
        } """

    // Upload to artifactory
    echo "Uploading android, centos, mac and windows artifacts (if none were skipped)."
    try {
        kServer.upload spec: uploadSpec, buildInfo: buildInfo, failNoOp: true
        kServer.publishBuildInfo buildInfo
    } catch (Exception eUploadProj) {
        echo "Unable to archive the artifacts for ${JOB_NAME}"
        throw eUploadProj
    }
}

// Create the string that describes this build, and add links to the artifactory packages.
def writeBuildInfoToJenkins() {
    unstashAll()
    def description = "Built on branch: ${repoBranch}, "
    def winDesc =  "Windows: ${winAgentName}"

    def httpPath = "${kArtifactoryPath}/${projName}/${JOB_NAME}/${BUILD_NUMBER}"
    description = description + "on nodes:<br>" +
            "${winDesc}<br>"

    // Set the build description text
    description = description  +
            jTools.create_build_description(httpPath,"Windows", '*.exe') +
            jTools.create_build_description(httpPath,"Windows", '*.log') +
            jTools.create_build_description(httpPath,"Windows", '*.zip')
    // Finally, set the description.
    currentBuild.setDescription(description)
}

// The pipeline for the RDP Build jobs, all permutations.
pipeline {
    agent { label workNodeLabel }
    stages {
        stage ('Initialize things') {
            // Load the tools library and from common-Scripts, and set the job variables.            
            steps {
                script {
                    echo "setting jTools"
                    jTools = setupTools()
                    echo "setting job vars"
                    setupJobVars()
                }
            }
        }
        stage ('Build') {
            // Build Ubuntu, Centos, Mac, and Windows packages in parallel.
            steps {
                script {
                    buildWindows(winBuildLabel)
                }
            }
        }

        stage ('Archive anything produced by the build') {
            // On one node, extract all the stashes and create the archives for artifactory, then upload them.
            steps {
                // if there's anything, archive it
                archivePackages()
            }
        }
        stage ('Create the build information block for the build run') {
            // Create the label to be written to the build description.
            steps {
                writeBuildInfoToJenkins()
            }
        }
    }
    post {
        failure {
            node (workNodeLabel) {
                // if there's a list of interested parties for failure, let them know.
                script {
                    echo "The build failed."
                    if (emailRecipFail != "") {
                        jTools.notifyFailed(emailRecipFail)
                    }
                }
            }
        }
        success {
            node (workNodeLabel) {
                script {
                    echo "The build script succeeded"
                    // similarly, if there's a list of people who want to know that it succeeded.
                    if (emailRecipSuccess != "") {
                        jTools.notifySuccessful(emailRecipSuccess)
                    }
                }
            }
        }
    }
}
